// Code generated by protoc-gen-go. DO NOT EDIT.
// source: common/configuration.proto

package common

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// HashingAlgorithm is encoded into the configuration transaction as  a configuration item of type Chain
// with a Key of "HashingAlgorithm" and a Value of  HashingAlgorithm as marshaled protobuf bytes
type HashingAlgorithm struct {
	// Currently supported algorithms are: SHAKE256
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *HashingAlgorithm) Reset()                    { *m = HashingAlgorithm{} }
func (m *HashingAlgorithm) String() string            { return proto.CompactTextString(m) }
func (*HashingAlgorithm) ProtoMessage()               {}
func (*HashingAlgorithm) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *HashingAlgorithm) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// BlockDataHashingStructure is encoded into the configuration transaction as a configuration item of
// type Chain with a Key of "BlockDataHashingStructure" and a Value of HashingAlgorithm as marshaled protobuf bytes
type BlockDataHashingStructure struct {
	// width specifies the width of the Merkle tree to use when computing the BlockDataHash
	// in order to replicate flat hashing, set this width to MAX_UINT32
	Width uint32 `protobuf:"varint,1,opt,name=width" json:"width,omitempty"`
}

func (m *BlockDataHashingStructure) Reset()                    { *m = BlockDataHashingStructure{} }
func (m *BlockDataHashingStructure) String() string            { return proto.CompactTextString(m) }
func (*BlockDataHashingStructure) ProtoMessage()               {}
func (*BlockDataHashingStructure) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *BlockDataHashingStructure) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

// OrdererAddresses is encoded into the configuration transaction as a configuration item of type Chain
// with a Key of "OrdererAddresses" and a Value of OrdererAddresses as marshaled protobuf bytes
type OrdererAddresses struct {
	Addresses []string `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
}

func (m *OrdererAddresses) Reset()                    { *m = OrdererAddresses{} }
func (m *OrdererAddresses) String() string            { return proto.CompactTextString(m) }
func (*OrdererAddresses) ProtoMessage()               {}
func (*OrdererAddresses) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *OrdererAddresses) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// Consortium represents the consortium context in which the channel was created
type Consortium struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Consortium) Reset()                    { *m = Consortium{} }
func (m *Consortium) String() string            { return proto.CompactTextString(m) }
func (*Consortium) ProtoMessage()               {}
func (*Consortium) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *Consortium) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*HashingAlgorithm)(nil), "common.HashingAlgorithm")
	proto.RegisterType((*BlockDataHashingStructure)(nil), "common.BlockDataHashingStructure")
	proto.RegisterType((*OrdererAddresses)(nil), "common.OrdererAddresses")
	proto.RegisterType((*Consortium)(nil), "common.Consortium")
}

func init() { proto.RegisterFile("common/configuration.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 222 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x8f, 0x41, 0x4b, 0x03, 0x31,
	0x10, 0x85, 0x59, 0xd4, 0xc2, 0x0e, 0x08, 0x25, 0x78, 0xa8, 0xe2, 0x61, 0x59, 0x41, 0x8a, 0x87,
	0x5d, 0xc5, 0x5f, 0xd0, 0xea, 0xc1, 0x9b, 0xb8, 0xde, 0xbc, 0xa5, 0xd9, 0x98, 0x0c, 0xed, 0x66,
	0x64, 0x32, 0xc1, 0xbf, 0x2f, 0x26, 0x96, 0xbd, 0x78, 0x7b, 0x5f, 0xf2, 0x3d, 0x98, 0x07, 0x57,
	0x86, 0xa6, 0x89, 0x42, 0x6f, 0x28, 0x7c, 0xa2, 0x4b, 0xac, 0x05, 0x29, 0x74, 0x5f, 0x4c, 0x42,
	0x6a, 0x51, 0xfe, 0xda, 0x5b, 0x58, 0xbe, 0xe8, 0xe8, 0x31, 0xb8, 0xcd, 0xc1, 0x11, 0xa3, 0xf8,
	0x49, 0x29, 0x38, 0x0d, 0x7a, 0xb2, 0xab, 0xaa, 0xa9, 0xd6, 0xf5, 0x90, 0x73, 0xfb, 0x00, 0x97,
	0xdb, 0x03, 0x99, 0xfd, 0xb3, 0x16, 0xfd, 0x57, 0x78, 0x17, 0x4e, 0x46, 0x12, 0x5b, 0x75, 0x01,
	0x67, 0xdf, 0x38, 0x8a, 0xcf, 0x8d, 0xf3, 0xa1, 0x40, 0x7b, 0x0f, 0xcb, 0x57, 0x1e, 0x2d, 0x5b,
	0xde, 0x8c, 0x23, 0xdb, 0x18, 0x6d, 0x54, 0xd7, 0x50, 0xeb, 0x23, 0xac, 0xaa, 0xe6, 0x64, 0x5d,
	0x0f, 0xf3, 0x43, 0xdb, 0x00, 0x3c, 0x51, 0x88, 0xc4, 0x82, 0xe9, 0xdf, 0x33, 0xb6, 0x6f, 0x70,
	0x43, 0xec, 0x3a, 0x0c, 0x7b, 0xe3, 0x35, 0x86, 0x39, 0xe4, 0x55, 0xb1, 0x2b, 0xab, 0x3e, 0xee,
	0x1c, 0x8a, 0x4f, 0xbb, 0x5f, 0xec, 0x8f, 0xca, 0x1c, 0x8a, 0xdb, 0x17, 0x77, 0xb7, 0xc8, 0xf8,
	0xf8, 0x13, 0x00, 0x00, 0xff, 0xff, 0x5f, 0xc1, 0xa7, 0x60, 0x2e, 0x01, 0x00, 0x00,
}
